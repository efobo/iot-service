data-simulator - генерирует пакет с какими-то произвольными данными. Отправляет эти данные на iot-контроллер, который пишет их в MongoDB
rule-engine через RabbitMQ принимает эти правила и что-то с ними делает.
Все служебные логи из этих сервисов должны заливаться в elk. Еще должны быть некоторые любые метрики и они должны отсылаться в Prometheus.
При этом 
1) нужно отвечать пользователю ошибками, давая максимальное количество полезной для него информации. Возвращать 503, 404, прочее.
2) Логгирование и мониторинг ошибок. Логи нужно писать, если случился nullpointer, нужно отправлять это в хранилище логов.


iot:
1) загружаются переменные окружения из файла .env. Если файл не удается загрузить, происходит обработка ошибки и завершение программы.
2) Подключение к RabbitMQ по адресу amqp://guest:guest@rabbitmq:5672/ (ampq, потому что подключение через библиотеку ampq. Не знаю есть ли такая в питоне)
Создается канал для работы с очередями RabbitMQ
3) Создается подключение к MongoDB с использованием данных из переменных окружения.
Подключение к БД и выбор нужной коллекции.
4) Инициализация логирования через logstash и настройка подключения на основе переменных окружения
5) Инициализация gRPC сервера для обмена данными между клиентом и сервером. Включает настройку порта и протокола для gRPC (Это не обязательно делать через gRPS)
Создается новый сервер gRPC, на котором регистрируется сервис обработки запросов
6) Инициализация и регистрация метрики Prometheus для отслеживания кол-ва запросов и их длительности. Отдельно запускается HTTP сервер для сбора и предоставления метрик на порту, указанном в переменных окружения
7) В StreamWithAck сервер обрабатывает поток данных от клиентов. Каждый запрос содержит данные устройства. После получения данных сервер записывает их в MongoDB и отправляет в RabbitMQ.
8) Для каждого устройства создается новый документ, который вставляется в MongoDB через асинхронную операцию.
9) Данные об устройстве сериализуются в JSON и отправляются в RabbitMQ через канал. В случае успешной отправки данных в RabbitMQ, результат отправляется обратно в gRPC клиент.
10) В случае ошибок на любом этапе (подключение к RabbitMQ, MongoDB, gRPC или Logstash) вызывается функция HandleError, которая логирует ошибку и завершает выполнение программы.
11) В models.go определена структура Document, которая используется для хранения данных об устройстве (ID устройства, метка времени и дополнительное поле). Структура используется при вставке данных в MongoDB.
12) В файле iotController.proto определена спецификация gRPC сервиса IotService, который включает метод StreamWithAck, принимающий поток запросов и отправляющий поток ответов.
13) В service.go находится основной сервис Service, который инкапсулирует логику работы с MongoDB, RabbitMQ и логированием через Logstash. В отдельных файлах, таких как datastream.go, rabbithole.go, реализованы методы для вставки данных в MongoDB и отправки их в RabbitMQ.
14) Запускается главный gRPC сервер, который начинает прослушивание входящих соединений и обработку запросов.